
MODULE FIELD_1LM_MODULE


USE OML_MOD, ONLY: OML_MAX_THREADS , OML_MY_THREAD 
USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
USE DEV_ALLOC_MODULE
USE HOST_ALLOC_MODULE
USE FIELD_BASIC_MODULE
USE FIELD_CONSTANTS_MODULE
USE FIELD_DEFAULTS_MODULE
USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM

USE FIELD_1LM_DATA_MODULE, ONLY : FIELD_1LM_COPY_INTF

IMPLICIT NONE

PRIVATE

TYPE, ABSTRACT, EXTENDS (FIELD_BASIC) :: FIELD_1LM
  LOGICAL(KIND=JPLM), POINTER :: PTR(:) => NULL()
  LOGICAL(KIND=JPLM), POINTER, CONTIGUOUS :: DEVPTR(:) => NULL()
  PROCEDURE (FIELD_1LM_COPY_INTF), POINTER, NOPASS :: COPY_FUNC => NULL ()
CONTAINS

  PROCEDURE :: FINAL => FIELD_1LM_FINAL
  PROCEDURE :: FIELD_1LM_FINAL
  PROCEDURE :: DELETE_DEVICE_DATA => FIELD_1LM_DELETE_DEVICE_DATA
  PROCEDURE :: GET_DEVICE_DATA_RDONLY => FIELD_1LM_GET_DEVICE_DATA_RDONLY
  PROCEDURE :: GET_DEVICE_DATA_WRONLY => FIELD_1LM_GET_DEVICE_DATA_WRONLY
  PROCEDURE :: GET_DEVICE_DATA_RDWR => FIELD_1LM_GET_DEVICE_DATA_RDWR
  PROCEDURE :: GET_HOST_DATA_RDONLY => FIELD_1LM_GET_HOST_DATA_RDONLY
  PROCEDURE :: GET_HOST_DATA_RDWR => FIELD_1LM_GET_HOST_DATA_RDWR
  PROCEDURE :: SYNC_HOST_RDWR => FIELD_1LM_SYNC_HOST_RDWR
  PROCEDURE :: SYNC_HOST_RDONLY => FIELD_1LM_SYNC_HOST_RDONLY
  PROCEDURE :: SYNC_DEVICE_RDWR => FIELD_1LM_SYNC_DEVICE_RDWR
  PROCEDURE :: SYNC_DEVICE_RDONLY => FIELD_1LM_SYNC_DEVICE_RDONLY
  PROCEDURE :: COPY_OBJECT => FIELD_1LM_COPY_OBJECT
  PROCEDURE :: WIPE_OBJECT => FIELD_1LM_WIPE_OBJECT
  PROCEDURE(GET_DIMS), DEFERRED :: GET_DIMS
  PROCEDURE(RESIZE), DEFERRED :: RESIZE

  PROCEDURE :: GET_DEVICE_DATA => FIELD_1LM_GET_DEVICE_DATA
  PROCEDURE :: GET_HOST_DATA => FIELD_1LM_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_1LM_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_1LM_GET_DEVICE_DATA
  PROCEDURE, PRIVATE :: COPY_DATA =>  FIELD_1LM_COPY_DATA
  PROCEDURE :: CREATE_DEVICE_DATA => FIELD_1LM_CREATE_DEVICE_DATA
  PROCEDURE :: CRC64 => FIELD_1LM_CRC64
#ifdef __PGI
  PROCEDURE :: SET_STATUS => FIELD_1LM_SET_STATUS
#endif
END TYPE FIELD_1LM

ABSTRACT INTERFACE
  SUBROUTINE GET_DIMS(SELF, LBOUNDS, UBOUNDS)
    USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM
    IMPORT ::  FIELD_1LM
    CLASS(FIELD_1LM),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(1)
  END SUBROUTINE GET_DIMS
  SUBROUTINE RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM
    IMPORT ::  FIELD_1LM
    CLASS(FIELD_1LM),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(1)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
  END SUBROUTINE RESIZE
END INTERFACE

PUBLIC :: FIELD_1LM

TYPE, EXTENDS(FIELD_1LM) :: FIELD_1LM_WRAPPER
  LOGICAL :: SYNC_ON_FINAL = .TRUE.
CONTAINS
  PROCEDURE :: INIT => FIELD_1LM_WRAPPER_INIT
  PROCEDURE :: FINAL => FIELD_1LM_WRAPPER_FINAL
  PROCEDURE :: GET_DIMS => FIELD_1LM_WRAPPER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_1LM_WRAPPER_RESIZE
END TYPE FIELD_1LM_WRAPPER

PUBLIC :: FIELD_1LM_WRAPPER

TYPE, EXTENDS(FIELD_1LM) :: FIELD_1LM_OWNER
  INTEGER(KIND=JPIM) :: LBOUNDS(1), UBOUNDS(1)
  LOGICAL :: HAS_INIT_VALUE = .FALSE.
  LOGICAL :: PINNED = .FALSE.
  LOGICAL :: POOLED = .FALSE.
  LOGICAL(KIND=JPLM) :: INIT_VALUE
CONTAINS
  PROCEDURE :: INIT => FIELD_1LM_OWNER_INIT
  PROCEDURE :: FINAL => FIELD_1LM_OWNER_FINAL
  PROCEDURE, PRIVATE :: CREATE_HOST_DATA => FIELD_1LM_OWNER_CREATE_HOST_DATA
  PROCEDURE :: GET_HOST_DATA => FIELD_1LM_OWNER_GET_HOST_DATA
  PROCEDURE :: GET_DEVICE_DATA => FIELD_1LM_OWNER_GET_DEVICE_DATA
  PROCEDURE :: GET_DIMS => FIELD_1LM_OWNER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_1LM_OWNER_RESIZE
END TYPE FIELD_1LM_OWNER

PUBLIC :: FIELD_1LM_OWNER

TYPE FIELD_1LM_PTR
  CLASS(FIELD_1LM), POINTER :: PTR => NULL()
END TYPE FIELD_1LM_PTR

PUBLIC :: FIELD_1LM_PTR



CONTAINS

  SUBROUTINE FIELD_1LM_WRAPPER_INIT(SELF, DATA, PERSISTENT, LBOUNDS, MAP_DEVPTR, SYNC_ON_FINAL, INITIALIZED)
    USE FIELD_ABORT_MODULE
    USE FIELD_DEFAULTS_MODULE
    USE FIELD_1LM_DATA_MODULE, ONLY : FIELD_1LM_COPY_FUNC

    ! Create FIELD object by wrapping existing data
    CLASS(FIELD_1LM_WRAPPER) :: SELF
    LOGICAL(KIND=JPLM), TARGET, INTENT(IN) :: DATA(:)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    LOGICAL, INTENT(IN), OPTIONAL :: MAP_DEVPTR
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(1)
    LOGICAL, INTENT(IN), OPTIONAL :: SYNC_ON_FINAL
    LOGICAL, INTENT(IN), OPTIONAL :: INITIALIZED
    
    LOGICAL :: LLPERSISTENT
    LOGICAL :: LLINITIALIZED

#include "abor1.intfb.h"

    LLPERSISTENT = .TRUE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    LLINITIALIZED = .TRUE.
    IF (PRESENT (INITIALIZED)) LLINITIALIZED = INITIALIZED

    IF (PRESENT(LBOUNDS)) THEN
      SELF%PTR(LBOUNDS(1):) => DATA
    ELSE
      SELF%PTR => DATA
    ENDIF

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (LLINITIALIZED) THEN
      CALL SELF%SET_STATUS (NHSTFRESH)
    ELSE
      CALL SELF%SET_STATUS (UNINITIALIZED)
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("FIELD_1LM_WRAPPER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF

    SELF%SYNC_ON_FINAL = INIT_SYNC_ON_FINAL
    IF (PRESENT (SYNC_ON_FINAL)) THEN
      SELF%SYNC_ON_FINAL = SYNC_ON_FINAL
    ENDIF

    IF (.NOT. LLPERSISTENT) THEN
      IF (OML_MAX_THREADS () /= SIZE (DATA, 1)) THEN
        CALL FIELD_ABORT ('FIELD_1LM_WRAPPER_INIT: DIMENSION MISMATCH')
      ENDIF
    ENDIF

    SELF%COPY_FUNC => FIELD_1LM_COPY_FUNC (SELF%PTR, SELF%DEVPTR)

  END SUBROUTINE FIELD_1LM_WRAPPER_INIT

  SUBROUTINE FIELD_1LM_OWNER_INIT (SELF, LBOUNDS, UBOUNDS, PERSISTENT, DELAYED, INIT_VALUE, PINNED, MAP_DEVPTR, POOLED)
    USE FIELD_ABORT_MODULE 
    USE FIELD_1LM_DATA_MODULE, ONLY : FIELD_1LM_COPY_FUNC

    CLASS(FIELD_1LM_OWNER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(1)
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(1)
    LOGICAL, OPTIONAL,  INTENT(IN) :: PERSISTENT
    LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
    LOGICAL, OPTIONAL,  INTENT(IN) :: PINNED
    LOGICAL, OPTIONAL,  INTENT(IN) :: MAP_DEVPTR
    LOGICAL, OPTIONAL,  INTENT(IN) :: POOLED
    LOGICAL(KIND=JPLM), OPTIONAL, INTENT(IN) :: INIT_VALUE
    LOGICAL :: IS_DELAYED
    LOGICAL :: LLPERSISTENT

#include "abor1.intfb.h"

    IS_DELAYED = .FALSE.
    IF(PRESENT(DELAYED))THEN
      IS_DELAYED = DELAYED
    ENDIF

    LLPERSISTENT = .FALSE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    SELF%POOLED = POOL_OWNED_FIELDS
    IF(PRESENT(PINNED))THEN
      SELF%PINNED = PINNED
    ENDIF
    IF(PRESENT(POOLED))THEN
      SELF%POOLED = POOLED
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("FIELD_1LM_OWNER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF

    IF (PRESENT (LBOUNDS)) THEN
      SELF%LBOUNDS=LBOUNDS
    ELSE
      SELF%LBOUNDS=1
    ENDIF

    SELF%UBOUNDS=UBOUNDS

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (.NOT. LLPERSISTENT) THEN
      SELF%LBOUNDS(1) = 1
      SELF%UBOUNDS(1) = OML_MAX_THREADS ()
    ENDIF

    CALL SELF%SET_STATUS (UNALLOCATED)
    IF (PRESENT(INIT_VALUE)) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_VALUE
    ELSE IF(USE_INIT_DEBUG_VALUE) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_DEBUG_VALUE_JPLM
    ENDIF
    IF(.NOT. IS_DELAYED) THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF

    SELF%COPY_FUNC => FIELD_1LM_COPY_FUNC ()

  END SUBROUTINE FIELD_1LM_OWNER_INIT

  SUBROUTINE FIELD_1LM_OWNER_CREATE_HOST_DATA (SELF)
    ! Create FIELD object by explicitly allocating new data
    CLASS(FIELD_1LM_OWNER) :: SELF

    IF(SELF%POOLED)THEN
       CALL HOST_ALLOC_POOLED(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%BLKID)
    ELSE
       CALL HOST_ALLOC(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%PINNED)
    ENDIF
    CALL SELF%SET_STATUS (UNINITIALIZED)
  END SUBROUTINE FIELD_1LM_OWNER_CREATE_HOST_DATA


  SUBROUTINE FIELD_1LM_DELETE_DEVICE_DATA(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(FIELD_1LM) :: SELF

    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      CALL DEV_DEALLOCATE (SELF%DEVPTR, SELF%MAP_DEVPTR)
    ENDIF

  END SUBROUTINE FIELD_1LM_DELETE_DEVICE_DATA

  SUBROUTINE FIELD_1LM_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_1LM) :: SELF
    NULLIFY(SELF%PTR)
    CALL SELF%DELETE_DEVICE_DATA()
  END SUBROUTINE FIELD_1LM_FINAL

  SUBROUTINE FIELD_1LM_WRAPPER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_1LM_WRAPPER) :: SELF
    LOGICAL(KIND=JPLM), POINTER :: PTR(:)
    IF (SELF%SYNC_ON_FINAL) THEN
      CALL SELF%GET_HOST_DATA_RDONLY(PTR)
    ENDIF
    CALL SELF%FIELD_1LM_FINAL
  END SUBROUTINE FIELD_1LM_WRAPPER_FINAL

  SUBROUTINE FIELD_1LM_OWNER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_1LM_OWNER) :: SELF

    IF(ASSOCIATED(SELF%PTR))THEN
       IF(SELF%POOLED)THEN
          CALL HOST_DEALLOC_POOLED (SELF%PTR, SELF%BLKID)
       ELSE
          CALL HOST_DEALLOC (SELF%PTR, SELF%PINNED)
       ENDIF
    ENDIF

    CALL SELF%FIELD_1LM_FINAL
  END SUBROUTINE FIELD_1LM_OWNER_FINAL

  SUBROUTINE FIELD_1LM_COPY_OBJECT (SELF, LDCREATED)

  USE FIELD_ABORT_MODULE

  CLASS(FIELD_1LM) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED
  LOGICAL :: LLCREATED

  LLCREATED = .FALSE.
  IF (PRESENT (LDCREATED)) LLCREATED = LDCREATED

  IF (.NOT. LLCREATED) CALL FIELD_ABORT ('FIELD_1LM_COPY_OBJECT: OBJECT WAS NOT CREATED')

  IF (.NOT. SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .TRUE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_1LM_COPY_OBJECT

  SUBROUTINE FIELD_1LM_WIPE_OBJECT (SELF, LDDELETED)

  USE FIELD_ABORT_MODULE

  CLASS(FIELD_1LM) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED
  LOGICAL :: LLDELETED

  LLDELETED = .FALSE.
  IF (PRESENT (LDDELETED)) LLDELETED = LDDELETED

  IF (.NOT. LLDELETED) CALL FIELD_ABORT ('FIELD_1LM_WIPE_OBJECT: OBJECT WAS NOT DELETED')

  IF (SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .FALSE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_1LM_WIPE_OBJECT

  SUBROUTINE FIELD_1LM_COPY_DATA (SELF, KDIR, QUEUE)

  CLASS(FIELD_1LM) :: SELF
  INTEGER (KIND=JPIM),           INTENT(IN) :: KDIR
  INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN) :: QUEUE
  REAL :: START, FINISH

  CALL CPU_TIME(START)
  CALL SELF%COPY_FUNC (SELF%PTR, SELF%DEVPTR, SELF%MAP_DEVPTR, KDIR, QUEUE)
  CALL CPU_TIME(FINISH)

  IF (KDIR == NH2D) THEN
    CALL SELF%STATS%INC_CPU_TO_GPU_TRANSFER(START, FINISH)
  ELSE IF (KDIR == ND2H) THEN
    CALL SELF%STATS%INC_GPU_TO_CPU_TRANSFER(START, FINISH)
  END IF

  END SUBROUTINE FIELD_1LM_COPY_DATA

  SUBROUTINE FIELD_1LM_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE

    LOGICAL(KIND=JPLM), POINTER,          INTENT(INOUT) :: PTR(:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    INTEGER(KIND=JPIM) :: LBOUNDS(1)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (IAND (SELF%GET_STATUS (), NHSTFRESH) == 0) THEN
      CALL SELF%COPY_DATA (ND2H, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NHSTFRESH))
    ENDIF
    PTR (LBOUNDS(1):) => SELF%PTR (:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%GET_STATUS (), NOT (NDEVFRESH)))
    ENDIF

  END SUBROUTINE FIELD_1LM_GET_HOST_DATA

  SUBROUTINE FIELD_1LM_OWNER_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_1LM_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    LOGICAL(KIND=JPLM), POINTER,          INTENT(INOUT) :: PTR(:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%GET_STATUS ()==UNALLOCATED)THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_1LM_GET_HOST_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_1LM_OWNER_GET_HOST_DATA

  SUBROUTINE FIELD_1LM_GET_HOST_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER,         INTENT(INOUT) :: PPTR(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_HOST_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_GET_HOST_DATA_RDONLY

  SUBROUTINE FIELD_1LM_SYNC_HOST_RDONLY (SELF, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    LOGICAL(KIND=JPLM), POINTER                        :: ZPTR(:)

    CALL SELF%GET_HOST_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_SYNC_HOST_RDONLY

  SUBROUTINE FIELD_1LM_GET_HOST_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER,         INTENT(INOUT) :: PPTR(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_HOST_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_GET_HOST_DATA_RDWR

  SUBROUTINE FIELD_1LM_SYNC_HOST_RDWR (SELF, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    LOGICAL(KIND=JPLM), POINTER                        :: ZPTR(:)

    CALL SELF%GET_HOST_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_SYNC_HOST_RDWR

  SUBROUTINE FIELD_1LM_CREATE_DEVICE_DATA (SELF)
    CLASS(FIELD_1LM) :: SELF

    CALL DEV_ALLOCATE_HST (DEV=SELF%DEVPTR, HST=SELF%PTR, MAP_DEVPTR=SELF%MAP_DEVPTR)
  END SUBROUTINE

  SUBROUTINE FIELD_1LM_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    LOGICAL(KIND=JPLM), POINTER,          INTENT(INOUT) :: PTR(:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM)                           :: LBOUNDS(1)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (.NOT. ASSOCIATED (SELF%DEVPTR)) THEN
      CALL SELF%CREATE_DEVICE_DATA
    ENDIF
    IF (IAND (SELF%GET_STATUS (), NDEVFRESH) == 0) THEN
      CALL SELF%COPY_DATA (NH2D, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    ENDIF
    PTR (LBOUNDS(1):) => SELF%DEVPTR (:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%GET_STATUS (), NOT (NHSTFRESH)))
    ENDIF

  END SUBROUTINE FIELD_1LM_GET_DEVICE_DATA

  INTEGER*8 FUNCTION FIELD_1LM_CRC64 (SELF) RESULT (ICRC)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER :: PTR(:)
    LOGICAL(KIND=JPLM), ALLOCATABLE :: ZZ(:)
    INTEGER*8 :: ILEN
    EXTERNAL :: CRC64
    
    ICRC = 0   
 
    IF (IAND (SELF%GET_STATUS (), NHSTFRESH) /= 0) THEN
      CALL SELF%GET_HOST_DATA_RDONLY (PTR)
      ILEN = SIZE (PTR) * KIND (PTR)
      CALL CRC64 (PTR, ILEN, ICRC)
    ELSEIF (IAND (SELF%GET_STATUS (), NDEVFRESH) /= 0) THEN
      CALL SELF%GET_DEVICE_DATA_RDONLY (PTR)
      ALLOCATE (ZZ, MOLD=PTR)

      ZZ = PTR

      ILEN = SIZE (ZZ) * KIND (ZZ)
      CALL CRC64 (ZZ, ILEN, ICRC)
    ENDIF

  END FUNCTION

  SUBROUTINE FIELD_1LM_OWNER_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_1LM_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    LOGICAL(KIND=JPLM), POINTER,          INTENT(INOUT) :: PTR(:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%GET_STATUS ()==UNALLOCATED)THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        CALL SELF%CREATE_DEVICE_DATA
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_1LM_GET_DEVICE_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_1LM_OWNER_GET_DEVICE_DATA

  SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER,         INTENT(INOUT) :: PPTR(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_DEVICE_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_RDONLY

  SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_WRONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER,         INTENT(INOUT) :: PPTR(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    CALL SELF%GET_DEVICE_DATA (NWR, PPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_WRONLY

  SUBROUTINE FIELD_1LM_SYNC_DEVICE_RDONLY (SELF, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    LOGICAL(KIND=JPLM), POINTER                        :: ZPTR(:)

    CALL SELF%GET_DEVICE_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_SYNC_DEVICE_RDONLY

  SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    LOGICAL(KIND=JPLM), POINTER,         INTENT(INOUT) :: PPTR(:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_DEVICE_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_GET_DEVICE_DATA_RDWR

  SUBROUTINE FIELD_1LM_SYNC_DEVICE_RDWR (SELF, QUEUE)
    CLASS(FIELD_1LM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    LOGICAL(KIND=JPLM), POINTER                        :: ZPTR(:)

    CALL SELF%GET_DEVICE_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_1LM_SYNC_DEVICE_RDWR

  SUBROUTINE FIELD_1LM_WRAPPER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_1LM_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(1)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=LBOUND(SELF%PTR)
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=UBOUND(SELF%PTR)
    ENDIF
  END SUBROUTINE FIELD_1LM_WRAPPER_GET_DIMS

  SUBROUTINE FIELD_1LM_OWNER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_1LM_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(1)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=SELF%LBOUNDS
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=SELF%UBOUNDS
    ENDIF
  END SUBROUTINE FIELD_1LM_OWNER_GET_DIMS

  SUBROUTINE FIELD_1LM_WRAPPER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)

    USE FIELD_ABORT_MODULE

    CLASS(FIELD_1LM_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(1)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
    CALL FIELD_ABORT("RESIZE NOT IMPLMENTED FOR WRAPPER")
  END SUBROUTINE FIELD_1LM_WRAPPER_RESIZE

  SUBROUTINE FIELD_1LM_OWNER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    CLASS(FIELD_1LM_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(1)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(1)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT

    LOGICAL :: DELAYED
    LOGICAL(KIND=JPLM) :: INIT_VALUE
    LOGICAL :: LLRESIZE
    INTEGER(KIND=JPIM) :: ILBOUND0(1)
    INTEGER(KIND=JPIM) :: ILBOUNDS(1)
    INTEGER(KIND=JPIM) :: IUBOUNDS(1)

    ILBOUND0 = 1
    IF (PRESENT (LBOUNDS)) ILBOUND0 = LBOUNDS

    CALL SELF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)

    LLRESIZE = ANY (UBOUNDS /= IUBOUNDS) .OR. ANY (ILBOUND0 /= ILBOUNDS)

    IF (LLRESIZE) THEN
      DELAYED=.NOT. ASSOCIATED(SELF%PTR)
      INIT_VALUE=SELF%INIT_VALUE
      CALL SELF%FINAL
      CALL SELF%INIT(UBOUNDS=UBOUNDS, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)
    ENDIF

  END SUBROUTINE FIELD_1LM_OWNER_RESIZE

#ifdef __PGI
  SUBROUTINE FIELD_1LM_SET_STATUS (SELF, KSTATUS)

  CLASS (FIELD_1LM) :: SELF
  INTEGER (KIND=JPIM), INTENT (IN) :: KSTATUS

  SELF%ISTATUS = KSTATUS

  END SUBROUTINE FIELD_1LM_SET_STATUS
#endif


END MODULE FIELD_1LM_MODULE
