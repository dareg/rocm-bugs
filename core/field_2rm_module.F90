
MODULE FIELD_2RM_MODULE


USE OML_MOD, ONLY: OML_MAX_THREADS , OML_MY_THREAD 
USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
USE DEV_ALLOC_MODULE
USE HOST_ALLOC_MODULE
USE FIELD_BASIC_MODULE
USE FIELD_CONSTANTS_MODULE
USE FIELD_DEFAULTS_MODULE
USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM

USE FIELD_2RM_DATA_MODULE, ONLY : FIELD_2RM_COPY_INTF

IMPLICIT NONE

PRIVATE

TYPE, ABSTRACT, EXTENDS (FIELD_BASIC) :: FIELD_2RM
  REAL(KIND=JPRM), POINTER :: PTR(:,:) => NULL()
  REAL(KIND=JPRM), POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
  PROCEDURE (FIELD_2RM_COPY_INTF), POINTER, NOPASS :: COPY_FUNC => NULL ()
CONTAINS

  PROCEDURE :: FINAL => FIELD_2RM_FINAL
  PROCEDURE :: FIELD_2RM_FINAL
  PROCEDURE :: DELETE_DEVICE_DATA => FIELD_2RM_DELETE_DEVICE_DATA
  PROCEDURE :: GET_VIEW => FIELD_2RM_GET_VIEW
  PROCEDURE :: GET_DEVICE_DATA_RDONLY => FIELD_2RM_GET_DEVICE_DATA_RDONLY
  PROCEDURE :: GET_DEVICE_DATA_WRONLY => FIELD_2RM_GET_DEVICE_DATA_WRONLY
  PROCEDURE :: GET_DEVICE_DATA_RDWR => FIELD_2RM_GET_DEVICE_DATA_RDWR
  PROCEDURE :: GET_HOST_DATA_RDONLY => FIELD_2RM_GET_HOST_DATA_RDONLY
  PROCEDURE :: GET_HOST_DATA_RDWR => FIELD_2RM_GET_HOST_DATA_RDWR
  PROCEDURE :: SYNC_HOST_RDWR => FIELD_2RM_SYNC_HOST_RDWR
  PROCEDURE :: SYNC_HOST_RDONLY => FIELD_2RM_SYNC_HOST_RDONLY
  PROCEDURE :: SYNC_DEVICE_RDWR => FIELD_2RM_SYNC_DEVICE_RDWR
  PROCEDURE :: SYNC_DEVICE_RDONLY => FIELD_2RM_SYNC_DEVICE_RDONLY
  PROCEDURE :: COPY_OBJECT => FIELD_2RM_COPY_OBJECT
  PROCEDURE :: WIPE_OBJECT => FIELD_2RM_WIPE_OBJECT
  PROCEDURE(GET_DIMS), DEFERRED :: GET_DIMS
  PROCEDURE(RESIZE), DEFERRED :: RESIZE

  PROCEDURE :: GET_DEVICE_DATA => FIELD_2RM_GET_DEVICE_DATA
  PROCEDURE :: GET_HOST_DATA => FIELD_2RM_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_2RM_GET_HOST_DATA
  PROCEDURE, PRIVATE :: FIELD_2RM_GET_DEVICE_DATA
  PROCEDURE, PRIVATE :: COPY_DATA =>  FIELD_2RM_COPY_DATA
  PROCEDURE :: CREATE_DEVICE_DATA => FIELD_2RM_CREATE_DEVICE_DATA
  PROCEDURE :: CRC64 => FIELD_2RM_CRC64
#ifdef __PGI
  PROCEDURE :: SET_STATUS => FIELD_2RM_SET_STATUS
#endif
END TYPE FIELD_2RM

ABSTRACT INTERFACE
  SUBROUTINE GET_DIMS(SELF, LBOUNDS, UBOUNDS)
    USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM
    IMPORT ::  FIELD_2RM
    CLASS(FIELD_2RM),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(2)
  END SUBROUTINE GET_DIMS
  SUBROUTINE RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM
    IMPORT ::  FIELD_2RM
    CLASS(FIELD_2RM),               INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(2)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
  END SUBROUTINE RESIZE
END INTERFACE

PUBLIC :: FIELD_2RM

TYPE, EXTENDS(FIELD_2RM) :: FIELD_2RM_WRAPPER
  LOGICAL :: SYNC_ON_FINAL = .TRUE.
CONTAINS
  PROCEDURE :: INIT => FIELD_2RM_WRAPPER_INIT
  PROCEDURE :: FINAL => FIELD_2RM_WRAPPER_FINAL
  PROCEDURE :: GET_DIMS => FIELD_2RM_WRAPPER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_2RM_WRAPPER_RESIZE
END TYPE FIELD_2RM_WRAPPER

PUBLIC :: FIELD_2RM_WRAPPER

TYPE, EXTENDS(FIELD_2RM) :: FIELD_2RM_OWNER
  INTEGER(KIND=JPIM) :: LBOUNDS(2), UBOUNDS(2)
  LOGICAL :: HAS_INIT_VALUE = .FALSE.
  LOGICAL :: PINNED = .FALSE.
  LOGICAL :: POOLED = .FALSE.
  REAL(KIND=JPRM) :: INIT_VALUE
CONTAINS
  PROCEDURE :: INIT => FIELD_2RM_OWNER_INIT
  PROCEDURE :: FINAL => FIELD_2RM_OWNER_FINAL
  PROCEDURE, PRIVATE :: CREATE_HOST_DATA => FIELD_2RM_OWNER_CREATE_HOST_DATA
  PROCEDURE :: GET_HOST_DATA => FIELD_2RM_OWNER_GET_HOST_DATA
  PROCEDURE :: GET_DEVICE_DATA => FIELD_2RM_OWNER_GET_DEVICE_DATA
  PROCEDURE :: GET_DIMS => FIELD_2RM_OWNER_GET_DIMS
  PROCEDURE :: RESIZE => FIELD_2RM_OWNER_RESIZE
END TYPE FIELD_2RM_OWNER

PUBLIC :: FIELD_2RM_OWNER

TYPE FIELD_2RM_PTR
  CLASS(FIELD_2RM), POINTER :: PTR => NULL()
END TYPE FIELD_2RM_PTR

PUBLIC :: FIELD_2RM_PTR

TYPE FIELD_2RM_VIEW
  REAL(KIND=JPRM), POINTER :: P(:) => NULL()
END TYPE FIELD_2RM_VIEW

PUBLIC :: FIELD_2RM_VIEW


CONTAINS

  SUBROUTINE FIELD_2RM_WRAPPER_INIT(SELF, DATA, PERSISTENT, LBOUNDS, MAP_DEVPTR, SYNC_ON_FINAL, INITIALIZED)
    USE FIELD_ABORT_MODULE
    USE FIELD_DEFAULTS_MODULE
    USE FIELD_2RM_DATA_MODULE, ONLY : FIELD_2RM_COPY_FUNC

    ! Create FIELD object by wrapping existing data
    CLASS(FIELD_2RM_WRAPPER) :: SELF
    REAL(KIND=JPRM), TARGET, INTENT(IN) :: DATA(:,:)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    LOGICAL, INTENT(IN), OPTIONAL :: MAP_DEVPTR
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
    LOGICAL, INTENT(IN), OPTIONAL :: SYNC_ON_FINAL
    LOGICAL, INTENT(IN), OPTIONAL :: INITIALIZED
    
    LOGICAL :: LLPERSISTENT
    LOGICAL :: LLINITIALIZED

#include "abor1.intfb.h"

    LLPERSISTENT = .TRUE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    LLINITIALIZED = .TRUE.
    IF (PRESENT (INITIALIZED)) LLINITIALIZED = INITIALIZED

    IF (PRESENT(LBOUNDS)) THEN
      SELF%PTR(LBOUNDS(1):, LBOUNDS(2):) => DATA
    ELSE
      SELF%PTR => DATA
    ENDIF

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (LLINITIALIZED) THEN
      CALL SELF%SET_STATUS (NHSTFRESH)
    ELSE
      CALL SELF%SET_STATUS (UNINITIALIZED)
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("FIELD_2RM_WRAPPER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF

    SELF%SYNC_ON_FINAL = INIT_SYNC_ON_FINAL
    IF (PRESENT (SYNC_ON_FINAL)) THEN
      SELF%SYNC_ON_FINAL = SYNC_ON_FINAL
    ENDIF

    IF (.NOT. LLPERSISTENT) THEN
      IF (OML_MAX_THREADS () /= SIZE (DATA, 2)) THEN
        CALL FIELD_ABORT ('FIELD_2RM_WRAPPER_INIT: DIMENSION MISMATCH')
      ENDIF
    ENDIF

    SELF%COPY_FUNC => FIELD_2RM_COPY_FUNC (SELF%PTR, SELF%DEVPTR)

  END SUBROUTINE FIELD_2RM_WRAPPER_INIT

  SUBROUTINE FIELD_2RM_OWNER_INIT (SELF, LBOUNDS, UBOUNDS, PERSISTENT, DELAYED, INIT_VALUE, PINNED, MAP_DEVPTR, POOLED)
    USE FIELD_ABORT_MODULE 
    USE FIELD_2RM_DATA_MODULE, ONLY : FIELD_2RM_COPY_FUNC

    CLASS(FIELD_2RM_OWNER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(2)
    LOGICAL, OPTIONAL,  INTENT(IN) :: PERSISTENT
    LOGICAL, OPTIONAL,  INTENT(IN) :: DELAYED
    LOGICAL, OPTIONAL,  INTENT(IN) :: PINNED
    LOGICAL, OPTIONAL,  INTENT(IN) :: MAP_DEVPTR
    LOGICAL, OPTIONAL,  INTENT(IN) :: POOLED
    REAL(KIND=JPRM), OPTIONAL, INTENT(IN) :: INIT_VALUE
    LOGICAL :: IS_DELAYED
    LOGICAL :: LLPERSISTENT

#include "abor1.intfb.h"

    IS_DELAYED = .FALSE.
    IF(PRESENT(DELAYED))THEN
      IS_DELAYED = DELAYED
    ENDIF

    LLPERSISTENT = .FALSE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT

    SELF%POOLED = POOL_OWNED_FIELDS
    IF(PRESENT(PINNED))THEN
      SELF%PINNED = PINNED
    ENDIF
    IF(PRESENT(POOLED))THEN
      SELF%POOLED = POOLED
    ENDIF

    SELF%MAP_DEVPTR = INIT_MAP_DEVPTR
    IF(PRESENT(MAP_DEVPTR))THEN
      SELF%MAP_DEVPTR = MAP_DEVPTR
    ENDIF
    IF(.NOT. SELF%MAP_DEVPTR)THEN
       CALL FIELD_ABORT ("FIELD_2RM_OWNER_INIT: CUDA backend needed to disable host-mapped device-pointer")
    ENDIF

    IF (PRESENT (LBOUNDS)) THEN
      SELF%LBOUNDS=LBOUNDS
    ELSE
      SELF%LBOUNDS=1
    ENDIF

    SELF%UBOUNDS=UBOUNDS

    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT

    IF (.NOT. LLPERSISTENT) THEN
      SELF%LBOUNDS(2) = 1
      SELF%UBOUNDS(2) = OML_MAX_THREADS ()
    ENDIF

    CALL SELF%SET_STATUS (UNALLOCATED)
    IF (PRESENT(INIT_VALUE)) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_VALUE
    ELSE IF(USE_INIT_DEBUG_VALUE) THEN
      SELF%HAS_INIT_VALUE=.TRUE.
      SELF%INIT_VALUE=INIT_DEBUG_VALUE_JPRM
    ENDIF
    IF(.NOT. IS_DELAYED) THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF

    SELF%COPY_FUNC => FIELD_2RM_COPY_FUNC ()

  END SUBROUTINE FIELD_2RM_OWNER_INIT

  SUBROUTINE FIELD_2RM_OWNER_CREATE_HOST_DATA (SELF)
    ! Create FIELD object by explicitly allocating new data
    CLASS(FIELD_2RM_OWNER) :: SELF

    IF(SELF%POOLED)THEN
       CALL HOST_ALLOC_POOLED(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%BLKID)
    ELSE
       CALL HOST_ALLOC(SELF%PTR, SELF%LBOUNDS, SELF%UBOUNDS, SELF%PINNED)
    ENDIF
    CALL SELF%SET_STATUS (UNINITIALIZED)
  END SUBROUTINE FIELD_2RM_OWNER_CREATE_HOST_DATA

  FUNCTION FIELD_2RM_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)

    USE FIELD_ABORT_MODULE

    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER :: VIEW_PTR(:)
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    LOGICAL, OPTIONAL,  INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: IDX
    INTEGER(KIND=JPIM) :: LBOUNDS(2)

    IF(IAND (SELF%GET_STATUS (),NHSTFRESH) /= NHSTFRESH) THEN
      CALL FIELD_ABORT ("GET_VIEW WAS CALLED, BUT DATA IS NOT PRESENT ON HOST")
    ENDIF

    IDX = BLOCK_INDEX
    IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD ()

    LBOUNDS=LBOUND(SELF%PTR)
    VIEW_PTR(LBOUNDS(1):) => SELF%PTR(:,IDX)

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) VIEW_PTR(:) = 0.0_JPRM
    END IF

    CALL SELF%SET_DEVICE_DIRTY ()

  END FUNCTION FIELD_2RM_GET_VIEW

  SUBROUTINE FIELD_2RM_DELETE_DEVICE_DATA(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(FIELD_2RM) :: SELF

    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      CALL DEV_DEALLOCATE (SELF%DEVPTR, SELF%MAP_DEVPTR)
    ENDIF

  END SUBROUTINE FIELD_2RM_DELETE_DEVICE_DATA

  SUBROUTINE FIELD_2RM_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_2RM) :: SELF
    NULLIFY(SELF%PTR)
    CALL SELF%DELETE_DEVICE_DATA()
  END SUBROUTINE FIELD_2RM_FINAL

  SUBROUTINE FIELD_2RM_WRAPPER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_2RM_WRAPPER) :: SELF
    REAL(KIND=JPRM), POINTER :: PTR(:,:)
    IF (SELF%SYNC_ON_FINAL) THEN
      CALL SELF%GET_HOST_DATA_RDONLY(PTR)
    ENDIF
    CALL SELF%FIELD_2RM_FINAL
  END SUBROUTINE FIELD_2RM_WRAPPER_FINAL

  SUBROUTINE FIELD_2RM_OWNER_FINAL(SELF)
    ! Finalizes field and deallocates owned data
    CLASS(FIELD_2RM_OWNER) :: SELF

    IF(ASSOCIATED(SELF%PTR))THEN
       IF(SELF%POOLED)THEN
          CALL HOST_DEALLOC_POOLED (SELF%PTR, SELF%BLKID)
       ELSE
          CALL HOST_DEALLOC (SELF%PTR, SELF%PINNED)
       ENDIF
    ENDIF

    CALL SELF%FIELD_2RM_FINAL
  END SUBROUTINE FIELD_2RM_OWNER_FINAL

  SUBROUTINE FIELD_2RM_COPY_OBJECT (SELF, LDCREATED)

  USE FIELD_ABORT_MODULE

  CLASS(FIELD_2RM) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED
  LOGICAL :: LLCREATED

  LLCREATED = .FALSE.
  IF (PRESENT (LDCREATED)) LLCREATED = LDCREATED

  IF (.NOT. LLCREATED) CALL FIELD_ABORT ('FIELD_2RM_COPY_OBJECT: OBJECT WAS NOT CREATED')

  IF (.NOT. SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .TRUE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_2RM_COPY_OBJECT

  SUBROUTINE FIELD_2RM_WIPE_OBJECT (SELF, LDDELETED)

  USE FIELD_ABORT_MODULE

  CLASS(FIELD_2RM) :: SELF
  LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED
  LOGICAL :: LLDELETED

  LLDELETED = .FALSE.
  IF (PRESENT (LDDELETED)) LLDELETED = LDDELETED

  IF (.NOT. LLDELETED) CALL FIELD_ABORT ('FIELD_2RM_WIPE_OBJECT: OBJECT WAS NOT DELETED')

  IF (SELF%LOBJECT_COPIED) THEN
    SELF%LOBJECT_COPIED = .FALSE.
#ifdef WITH_GPU_OFFLOAD
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      
    ENDIF
#endif
  ENDIF

  END SUBROUTINE FIELD_2RM_WIPE_OBJECT

  SUBROUTINE FIELD_2RM_COPY_DATA (SELF, KDIR, QUEUE)

  CLASS(FIELD_2RM) :: SELF
  INTEGER (KIND=JPIM),           INTENT(IN) :: KDIR
  INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN) :: QUEUE
  REAL :: START, FINISH

  CALL CPU_TIME(START)
  CALL SELF%COPY_FUNC (SELF%PTR, SELF%DEVPTR, SELF%MAP_DEVPTR, KDIR, QUEUE)
  CALL CPU_TIME(FINISH)

  IF (KDIR == NH2D) THEN
    CALL SELF%STATS%INC_CPU_TO_GPU_TRANSFER(START, FINISH)
  ELSE IF (KDIR == ND2H) THEN
    CALL SELF%STATS%INC_GPU_TO_CPU_TRANSFER(START, FINISH)
  END IF

  END SUBROUTINE FIELD_2RM_COPY_DATA

  SUBROUTINE FIELD_2RM_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE

    REAL(KIND=JPRM), POINTER,          INTENT(INOUT) :: PTR(:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    INTEGER(KIND=JPIM) :: LBOUNDS(2)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (IAND (SELF%GET_STATUS (), NHSTFRESH) == 0) THEN
      CALL SELF%COPY_DATA (ND2H, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NHSTFRESH))
    ENDIF
    PTR (LBOUNDS(1):, LBOUNDS(2):) => SELF%PTR (:,:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%GET_STATUS (), NOT (NDEVFRESH)))
    ENDIF

  END SUBROUTINE FIELD_2RM_GET_HOST_DATA

  SUBROUTINE FIELD_2RM_OWNER_GET_HOST_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_2RM_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRM), POINTER,          INTENT(INOUT) :: PTR(:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%GET_STATUS ()==UNALLOCATED)THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_2RM_GET_HOST_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_2RM_OWNER_GET_HOST_DATA

  SUBROUTINE FIELD_2RM_GET_HOST_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER,         INTENT(INOUT) :: PPTR(:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_HOST_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_GET_HOST_DATA_RDONLY

  SUBROUTINE FIELD_2RM_SYNC_HOST_RDONLY (SELF, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRM), POINTER                        :: ZPTR(:,:)

    CALL SELF%GET_HOST_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_SYNC_HOST_RDONLY

  SUBROUTINE FIELD_2RM_GET_HOST_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER,         INTENT(INOUT) :: PPTR(:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_HOST_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_GET_HOST_DATA_RDWR

  SUBROUTINE FIELD_2RM_SYNC_HOST_RDWR (SELF, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRM), POINTER                        :: ZPTR(:,:)

    CALL SELF%GET_HOST_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_SYNC_HOST_RDWR

  SUBROUTINE FIELD_2RM_CREATE_DEVICE_DATA (SELF)
    CLASS(FIELD_2RM) :: SELF

    CALL DEV_ALLOCATE_HST (DEV=SELF%DEVPTR, HST=SELF%PTR, MAP_DEVPTR=SELF%MAP_DEVPTR)
  END SUBROUTINE

  SUBROUTINE FIELD_2RM_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRM), POINTER,          INTENT(INOUT) :: PTR(:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    INTEGER(KIND=JPIM)                           :: LBOUNDS(2)

    LBOUNDS=LBOUND(SELF%PTR)
    IF (.NOT. ASSOCIATED (SELF%DEVPTR)) THEN
      CALL SELF%CREATE_DEVICE_DATA
    ENDIF
    IF (IAND (SELF%GET_STATUS (), NDEVFRESH) == 0) THEN
      CALL SELF%COPY_DATA (NH2D, QUEUE)
      CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    ENDIF
    PTR (LBOUNDS(1):, LBOUNDS(2):) => SELF%DEVPTR (:,:)
    IF (IAND (MODE, NWR) /= 0) THEN
      CALL SELF%SET_STATUS (IAND (SELF%GET_STATUS (), NOT (NHSTFRESH)))
    ENDIF

  END SUBROUTINE FIELD_2RM_GET_DEVICE_DATA

  INTEGER*8 FUNCTION FIELD_2RM_CRC64 (SELF) RESULT (ICRC)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER :: PTR(:,:)
    REAL(KIND=JPRM), ALLOCATABLE :: ZZ(:,:)
    INTEGER*8 :: ILEN
    EXTERNAL :: CRC64
    
    ICRC = 0   
 
    IF (IAND (SELF%GET_STATUS (), NHSTFRESH) /= 0) THEN
      CALL SELF%GET_HOST_DATA_RDONLY (PTR)
      ILEN = SIZE (PTR) * KIND (PTR)
      CALL CRC64 (PTR, ILEN, ICRC)
    ELSEIF (IAND (SELF%GET_STATUS (), NDEVFRESH) /= 0) THEN
      CALL SELF%GET_DEVICE_DATA_RDONLY (PTR)
      ALLOCATE (ZZ, MOLD=PTR)

      ZZ = PTR

      ILEN = SIZE (ZZ) * KIND (ZZ)
      CALL CRC64 (ZZ, ILEN, ICRC)
    ENDIF

  END FUNCTION

  SUBROUTINE FIELD_2RM_OWNER_GET_DEVICE_DATA (SELF, MODE, PTR, QUEUE)
    CLASS(FIELD_2RM_OWNER) :: SELF
    INTEGER (KIND=JPIM),           INTENT(IN)    :: MODE
    REAL(KIND=JPRM), POINTER,          INTENT(INOUT) :: PTR(:,:)
    INTEGER (KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    IF(SELF%GET_STATUS ()==UNALLOCATED)THEN
      CALL SELF%CREATE_HOST_DATA ()
      IF (SELF%HAS_INIT_VALUE) THEN
        CALL SELF%CREATE_DEVICE_DATA
        SELF%PTR=SELF%INIT_VALUE
        CALL SELF%SET_STATUS (NHSTFRESH)
      ENDIF
    ENDIF
    CALL SELF%FIELD_2RM_GET_DEVICE_DATA(MODE, PTR, QUEUE)

  END SUBROUTINE FIELD_2RM_OWNER_GET_DEVICE_DATA

  SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_RDONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER,         INTENT(INOUT) :: PPTR(:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_DEVICE_DATA (NRD, PPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_RDONLY

  SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_WRONLY (SELF, PPTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER,         INTENT(INOUT) :: PPTR(:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%SET_STATUS (IOR (SELF%GET_STATUS (), NDEVFRESH))
    CALL SELF%GET_DEVICE_DATA (NWR, PPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_WRONLY

  SUBROUTINE FIELD_2RM_SYNC_DEVICE_RDONLY (SELF, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRM), POINTER                        :: ZPTR(:,:)

    CALL SELF%GET_DEVICE_DATA_RDONLY (ZPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_SYNC_DEVICE_RDONLY

  SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_RDWR (SELF, PPTR, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    REAL(KIND=JPRM), POINTER,         INTENT(INOUT) :: PPTR(:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE

    CALL SELF%GET_DEVICE_DATA (IOR (NRD, NWR), PPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_GET_DEVICE_DATA_RDWR

  SUBROUTINE FIELD_2RM_SYNC_DEVICE_RDWR (SELF, QUEUE)
    CLASS(FIELD_2RM) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: QUEUE
    REAL(KIND=JPRM), POINTER                        :: ZPTR(:,:)

    CALL SELF%GET_DEVICE_DATA_RDWR (ZPTR, QUEUE)

  END SUBROUTINE FIELD_2RM_SYNC_DEVICE_RDWR

  SUBROUTINE FIELD_2RM_WRAPPER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_2RM_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(2)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=LBOUND(SELF%PTR)
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=UBOUND(SELF%PTR)
    ENDIF
  END SUBROUTINE FIELD_2RM_WRAPPER_GET_DIMS

  SUBROUTINE FIELD_2RM_OWNER_GET_DIMS (SELF, LBOUNDS, UBOUNDS)
    CLASS(FIELD_2RM_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: LBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(OUT) :: UBOUNDS(2)
    IF(PRESENT(LBOUNDS))THEN
      LBOUNDS=SELF%LBOUNDS
    ENDIF
    IF(PRESENT(UBOUNDS))THEN
      UBOUNDS=SELF%UBOUNDS
    ENDIF
  END SUBROUTINE FIELD_2RM_OWNER_GET_DIMS

  SUBROUTINE FIELD_2RM_WRAPPER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)

    USE FIELD_ABORT_MODULE

    CLASS(FIELD_2RM_WRAPPER),       INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(2)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT
    CALL FIELD_ABORT("RESIZE NOT IMPLMENTED FOR WRAPPER")
  END SUBROUTINE FIELD_2RM_WRAPPER_RESIZE

  SUBROUTINE FIELD_2RM_OWNER_RESIZE (SELF, UBOUNDS, LBOUNDS, PERSISTENT)
    CLASS(FIELD_2RM_OWNER),         INTENT(IN) :: SELF
    INTEGER(KIND=JPIM),           INTENT(IN) :: UBOUNDS(2)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS(2)
    LOGICAL, OPTIONAL,            INTENT(IN) :: PERSISTENT

    LOGICAL :: DELAYED
    REAL(KIND=JPRM) :: INIT_VALUE
    LOGICAL :: LLRESIZE
    INTEGER(KIND=JPIM) :: ILBOUND0(2)
    INTEGER(KIND=JPIM) :: ILBOUNDS(2)
    INTEGER(KIND=JPIM) :: IUBOUNDS(2)

    ILBOUND0 = 1
    IF (PRESENT (LBOUNDS)) ILBOUND0 = LBOUNDS

    CALL SELF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)

    LLRESIZE = ANY (UBOUNDS /= IUBOUNDS) .OR. ANY (ILBOUND0 /= ILBOUNDS)

    IF (LLRESIZE) THEN
      DELAYED=.NOT. ASSOCIATED(SELF%PTR)
      INIT_VALUE=SELF%INIT_VALUE
      CALL SELF%FINAL
      CALL SELF%INIT(UBOUNDS=UBOUNDS, LBOUNDS=LBOUNDS, PERSISTENT=PERSISTENT, DELAYED=DELAYED, INIT_VALUE=INIT_VALUE)
    ENDIF

  END SUBROUTINE FIELD_2RM_OWNER_RESIZE

#ifdef __PGI
  SUBROUTINE FIELD_2RM_SET_STATUS (SELF, KSTATUS)

  CLASS (FIELD_2RM) :: SELF
  INTEGER (KIND=JPIM), INTENT (IN) :: KSTATUS

  SELF%ISTATUS = KSTATUS

  END SUBROUTINE FIELD_2RM_SET_STATUS
#endif


END MODULE FIELD_2RM_MODULE
