
MODULE FIELD_1LM_UTIL_MODULE


USE FIELD_1LM_MODULE
USE FIELD_1LM_ACCESS_MODULE

USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM

IMPLICIT NONE


INTERFACE LOAD
  MODULE PROCEDURE LOAD_FIELD_1LM
  MODULE PROCEDURE LOAD_FIELD_1LM_PTR
END INTERFACE

INTERFACE SAVE
  MODULE PROCEDURE SAVE_FIELD_1LM
  MODULE PROCEDURE SAVE_FIELD_1LM_PTR
END INTERFACE

INTERFACE DIFF
  MODULE PROCEDURE DIFF_FIELD_1LM
END INTERFACE

INTERFACE COPY
  MODULE PROCEDURE COPY_FIELD_1LM
  MODULE PROCEDURE COPY_FIELD_1LM_PTR
END INTERFACE

INTERFACE WIPE
  MODULE PROCEDURE WIPE_FIELD_1LM
  MODULE PROCEDURE WIPE_FIELD_1LM_PTR
END INTERFACE

INTERFACE HOST
  MODULE PROCEDURE HOST_FIELD_1LM
  MODULE PROCEDURE HOST_FIELD_1LM_PTR
END INTERFACE

INTERFACE LEGACY
  MODULE PROCEDURE LEGACY_FIELD_1LM
END INTERFACE

INTERFACE CRC64
  MODULE PROCEDURE CRC64_FIELD_1LM
END INTERFACE


CONTAINS

INTEGER*8 FUNCTION CRC64_FIELD_1LM (YD)
CLASS (FIELD_1LM), POINTER :: YD
INTEGER*8 :: ICRC

ICRC = 0

IF (ASSOCIATED (YD)) THEN
  ICRC = YD%CRC64 ()
ENDIF

CRC64_FIELD_1LM = ICRC

END FUNCTION

SUBROUTINE LOAD_FIELD_1LM (KLUN, YD)

USE FIELD_ABORT_MODULE
USE PARKIND1, ONLY : JPIM

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
CLASS (FIELD_1LM), POINTER :: YD

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE

SUBROUTINE SAVE_FIELD_1LM (KLUN, YD)

USE FIELD_ABORT_MODULE
USE PARKIND1, ONLY : JPIM

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
CLASS (FIELD_1LM), POINTER :: YD

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE

SUBROUTINE DIFF_FIELD_1LM (CDMESS, YD, YO)

USE FIELD_ABORT_MODULE

CHARACTER (LEN=*), INTENT(IN) :: CDMESS
CLASS (FIELD_1LM), POINTER :: YD, YO

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE

SUBROUTINE COPY_FIELD_1LM (SELF, LDCREATED)

USE FIELD_ABORT_MODULE

CLASS (FIELD_1LM), POINTER :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE 

SUBROUTINE WIPE_FIELD_1LM (SELF, LDDELETED)

USE FIELD_ABORT_MODULE

CLASS (FIELD_1LM) :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE 

SUBROUTINE HOST_FIELD_1LM (SELF)
CLASS (FIELD_1LM), POINTER :: SELF

CALL SELF%SYNC_HOST_RDWR ()

END SUBROUTINE 

SUBROUTINE LEGACY_FIELD_1LM (SELF, KADDRL, KADDRU, KDIR)

USE FIELD_1LM_ACCESS_MODULE
USE FIELD_CONSTANTS_MODULE

CLASS (FIELD_1LM), POINTER :: SELF
INTEGER*8, INTENT (IN) :: KADDRL
INTEGER*8, INTENT (IN) :: KADDRU
INTEGER,   INTENT (IN) :: KDIR

LOGICAL(KIND=JPLM), POINTER :: PTR (:), DEVPTR (:)
INTEGER*8 :: IADDRL
INTEGER*8 :: IADDRU
INTEGER (KIND=JPIM) :: ILBOUNDS (1)
INTEGER (KIND=JPIM) :: IUBOUNDS (1)

IF (ASSOCIATED (SELF)) THEN

  CALL SELF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)

  PTR => SELF%PTR

  IADDRL = LOC (PTR (ILBOUNDS(1)))
  IADDRU = LOC (PTR (IUBOUNDS(1)))

  IF ((KADDRL <= IADDRL) .AND. (IADDRU <= KADDRU)) THEN

    IF (KDIR == NF2L) THEN
      DEVPTR => GET_DEVICE_DATA_RDONLY (SELF)
      CALL LEGACY_FIELD_1LM_ASSIGN (PTR, DEVPTR)
    ELSEIF (KDIR == NL2F) THEN
      DEVPTR => GET_DEVICE_DATA_RDWR (SELF)
      CALL LEGACY_FIELD_1LM_ASSIGN (DEVPTR, PTR)
    ENDIF

  ENDIF

ENDIF

CONTAINS

SUBROUTINE LEGACY_FIELD_1LM_ASSIGN (PTR_RHS, PTR_LHS)

LOGICAL(KIND=JPLM) :: PTR_RHS (:), PTR_LHS (:)


PTR_RHS = PTR_LHS


END SUBROUTINE

END SUBROUTINE 


SUBROUTINE LOAD_FIELD_1LM_PTR (KLUN, YD)

USE FIELD_ABORT_MODULE
USE PARKIND1, ONLY : JPIM

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
CLASS (FIELD_1LM_PTR) :: YD

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE

SUBROUTINE SAVE_FIELD_1LM_PTR (KLUN, YD)

USE FIELD_ABORT_MODULE
USE PARKIND1, ONLY : JPIM

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
CLASS (FIELD_1LM_PTR) :: YD

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE

SUBROUTINE COPY_FIELD_1LM_PTR (SELF, LDCREATED)

USE FIELD_ABORT_MODULE

CLASS (FIELD_1LM_PTR) :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDCREATED

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE 

SUBROUTINE WIPE_FIELD_1LM_PTR (SELF, LDDELETED)

USE FIELD_ABORT_MODULE

CLASS (FIELD_1LM_PTR) :: SELF
LOGICAL, INTENT (IN), OPTIONAL :: LDDELETED

CALL FIELD_ABORT ('NOT IMPLEMENTED')
END SUBROUTINE 

SUBROUTINE HOST_FIELD_1LM_PTR (SELF)
CLASS (FIELD_1LM_PTR) :: SELF

IF (ASSOCIATED (SELF%PTR)) THEN
  CALL HOST (SELF%PTR)
ENDIF

END SUBROUTINE 


END MODULE
