
MODULE FIELD_5LM_SHUFFLE_MODULE


USE FIELD_5LM_MODULE
USE FIELD_5LM_ACCESS_MODULE
USE FIELD_5LM_FACTORY_MODULE

USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM

IMPLICIT NONE

PRIVATE



INTERFACE PAIR_GATHER_DEVICE_DATA_RDONLY
  MODULE PROCEDURE :: PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDONLY
END INTERFACE PAIR_GATHER_DEVICE_DATA_RDONLY

PUBLIC :: PAIR_GATHER_DEVICE_DATA_RDONLY


INTERFACE PAIR_GATHER_DEVICE_DATA_RDWR
  MODULE PROCEDURE :: PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDWR
END INTERFACE PAIR_GATHER_DEVICE_DATA_RDWR

PUBLIC :: PAIR_GATHER_DEVICE_DATA_RDWR


INTERFACE PAIR_GATHER_HOST_DATA_RDONLY
  MODULE PROCEDURE :: PAIR_FIELD_5LM_GATHER_HOST_DATA_RDONLY
END INTERFACE PAIR_GATHER_HOST_DATA_RDONLY

PUBLIC :: PAIR_GATHER_HOST_DATA_RDONLY


INTERFACE PAIR_GATHER_HOST_DATA_RDWR
  MODULE PROCEDURE :: PAIR_FIELD_5LM_GATHER_HOST_DATA_RDWR
END INTERFACE PAIR_GATHER_HOST_DATA_RDWR

PUBLIC :: PAIR_GATHER_HOST_DATA_RDWR


INTERFACE PAIR_SCATTER_DATA
  MODULE PROCEDURE :: PAIR_FIELD_5LM_SCATTER_DATA
END INTERFACE PAIR_SCATTER_DATA

PUBLIC :: PAIR_SCATTER_DATA

TYPE FIELD_5LM_SHUFFLE_PAIR
  INTEGER (KIND=JPIM) :: IMODE = -1
  INTEGER (KIND=JPIM) :: IWHAT = -1
  CLASS (FIELD_5LM), POINTER :: YLSCAT => NULL ()
  CLASS (FIELD_5LM), POINTER :: YLGATH => NULL ()
  TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: NEXT => NULL ()
END TYPE FIELD_5LM_SHUFFLE_PAIR

PUBLIC :: FIELD_5LM_SHUFFLE_PAIR


INTEGER (KIND=JPIM), PARAMETER :: NRDWR = 0, NRDONLY = 1, NHOST = 2, NDEVICE = 3
INTEGER (KIND=JPIM), PARAMETER :: NLONDIM = 1, NBLKDIM = 2

CONTAINS



SUBROUTINE PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDONLY (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
LOGICAL(KIND=JPLM),                      POINTER              :: PTR(:,:,:,:,:)
CLASS (FIELD_5LM),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

LOGICAL(KIND=JPLM), POINTER :: ZTRG(:,:,:,:,:), ZTRS(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTR1(:,:,:,:,:)
TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_5LM), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_DEVICE_DATA_RDONLY (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:,:,:,:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):,ILBOUNDS(2):,ILBOUNDS(3):,ILBOUNDS(4):, 1:) => PTR1

ELSE

  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDONLY
  YLPAIR%IWHAT = NDEVICE
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (5) = 1
  IUBOUNDS (5) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
  ZTRS => GET_DEVICE_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_DEVICE_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_5LM_DEVICE_RDONLY (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDONLY (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_5LM_DEVICE_RDONLY (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4


DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRG (JLONG, J2, J3, J4, JBLKG) = PTRS (JLONS, J2, J3, J4, JBLKS)
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDONLY


SUBROUTINE PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDWR (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
LOGICAL(KIND=JPLM),                      POINTER              :: PTR(:,:,:,:,:)
CLASS (FIELD_5LM),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

LOGICAL(KIND=JPLM), POINTER :: ZTRG(:,:,:,:,:), ZTRS(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTR1(:,:,:,:,:)
TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_5LM), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_DEVICE_DATA_RDWR (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDWR (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:,:,:,:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):,ILBOUNDS(2):,ILBOUNDS(3):,ILBOUNDS(4):, 1:) => PTR1

ELSE

  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDWR
  YLPAIR%IWHAT = NDEVICE
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (5) = 1
  IUBOUNDS (5) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
  ZTRS => GET_DEVICE_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_DEVICE_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_5LM_DEVICE_RDWR (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDWR (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_5LM_DEVICE_RDWR (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4


DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRG (JLONG, J2, J3, J4, JBLKG) = PTRS (JLONS, J2, J3, J4, JBLKS)
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_5LM_GATHER_DEVICE_DATA_RDWR


SUBROUTINE PAIR_FIELD_5LM_GATHER_HOST_DATA_RDONLY (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
LOGICAL(KIND=JPLM),                      POINTER              :: PTR(:,:,:,:,:)
CLASS (FIELD_5LM),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

LOGICAL(KIND=JPLM), POINTER :: ZTRG(:,:,:,:,:), ZTRS(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTR1(:,:,:,:,:)
TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_5LM), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_HOST_DATA_RDONLY (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDONLY (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:,:,:,:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):,ILBOUNDS(2):,ILBOUNDS(3):,ILBOUNDS(4):, 1:) => PTR1

ELSE

  PTR => GET_HOST_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDONLY
  YLPAIR%IWHAT = NHOST
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (5) = 1
  IUBOUNDS (5) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_HOST_DATA_RDONLY (YDFINDS)
  ZTRS => GET_HOST_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_HOST_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_5LM_HOST_RDONLY (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDONLY (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_5LM_HOST_RDONLY (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4

!$OMP PARALLEL DO PRIVATE (J2, J3, J4, JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRG (JLONG, J2, J3, J4, JBLKG) = PTRS (JLONS, J2, J3, J4, JBLKS)
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_5LM_GATHER_HOST_DATA_RDONLY


SUBROUTINE PAIR_FIELD_5LM_GATHER_HOST_DATA_RDWR (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
LOGICAL(KIND=JPLM),                      POINTER              :: PTR(:,:,:,:,:)
CLASS (FIELD_5LM),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

LOGICAL(KIND=JPLM), POINTER :: ZTRG(:,:,:,:,:), ZTRS(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTR1(:,:,:,:,:)
TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_5LM), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_HOST_DATA_RDWR (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDWR (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:,:,:,:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):,ILBOUNDS(2):,ILBOUNDS(3):,ILBOUNDS(4):, 1:) => PTR1

ELSE

  PTR => GET_HOST_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDWR
  YLPAIR%IWHAT = NHOST
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (5) = 1
  IUBOUNDS (5) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_HOST_DATA_RDONLY (YDFINDS)
  ZTRS => GET_HOST_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_HOST_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_5LM_HOST_RDWR (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDWR (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_5LM_HOST_RDWR (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4

!$OMP PARALLEL DO PRIVATE (J2, J3, J4, JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRG (JLONG, J2, J3, J4, JBLKG) = PTRS (JLONS, J2, J3, J4, JBLKS)
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_5LM_GATHER_HOST_DATA_RDWR



SUBROUTINE PAIR_FIELD_5LM_SCATTER_DATA (YDPAIR, YDFINDS)

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER              :: YDPAIR
CLASS (FIELD_3IM),               POINTER              :: YDFINDS 

TYPE (FIELD_5LM_SHUFFLE_PAIR), POINTER :: YLPAIR
LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:), PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

DO WHILE (ASSOCIATED (YDPAIR))

  YLPAIR => YDPAIR%NEXT

  ! Scatter back results
  IF (YDPAIR%IMODE == NRDWR) THEN
    IF (YDPAIR%IWHAT == NDEVICE) THEN

      INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
      PTRG => GET_DEVICE_DATA_RDONLY (YDPAIR%YLGATH)
      PTRS => GET_DEVICE_DATA_RDWR   (YDPAIR%YLSCAT)

      CALL FIELD_5LM_SCATTER_DEVICE_KERNEL (INDS, PTRG, PTRS)

    ELSEIF (YDPAIR%IWHAT == NHOST) THEN

      INDS => GET_HOST_DATA_RDONLY (YDFINDS)
      PTRG => GET_HOST_DATA_RDONLY (YDPAIR%YLGATH)
      PTRS => GET_HOST_DATA_RDWR   (YDPAIR%YLSCAT)

      CALL FIELD_5LM_SCATTER_HOST_KERNEL (INDS, PTRG, PTRS)

    ENDIF
  ENDIF

  CALL FIELD_DELETE (YDPAIR%YLGATH)
  DEALLOCATE (YDPAIR)
  NULLIFY (YDPAIR)

  YDPAIR => YLPAIR
ENDDO

CONTAINS

SUBROUTINE FIELD_5LM_SCATTER_DEVICE_KERNEL (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN) :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4


DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRS (JLONS, J2, J3, J4, JBLKS) = PTRG (JLONG, J2, J3, J4, JBLKG) 
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE FIELD_5LM_SCATTER_HOST_KERNEL (KNDS, PTRG, PTRS)

LOGICAL(KIND=JPLM), POINTER :: PTRG(:,:,:,:,:)
LOGICAL(KIND=JPLM), POINTER :: PTRS(:,:,:,:,:)
INTEGER (KIND=JPIM), INTENT (IN) :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG

INTEGER (KIND=JPIM) :: J2, J3, J4

!$OMP PARALLEL DO PRIVATE (J2, J3, J4, JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
      DO J4 = LBOUND (PTRG, 4), UBOUND (PTRG, 4)
      DO J3 = LBOUND (PTRG, 3), UBOUND (PTRG, 3)
      DO J2 = LBOUND (PTRG, 2), UBOUND (PTRG, 2)
        PTRS (JLONS, J2, J3, J4, JBLKS) = PTRG (JLONG, J2, J3, J4, JBLKG) 
      ENDDO
      ENDDO
      ENDDO
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_5LM_SCATTER_DATA


END MODULE FIELD_5LM_SHUFFLE_MODULE
