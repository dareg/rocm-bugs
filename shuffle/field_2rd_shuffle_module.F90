
MODULE FIELD_2RD_SHUFFLE_MODULE


USE FIELD_2RD_MODULE
USE FIELD_2RD_ACCESS_MODULE
USE FIELD_2RD_FACTORY_MODULE

USE PARKIND1, ONLY : JPRM, JPRD, JPIM, JPLM

IMPLICIT NONE

PRIVATE



INTERFACE PAIR_GATHER_DEVICE_DATA_RDONLY
  MODULE PROCEDURE :: PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDONLY
END INTERFACE PAIR_GATHER_DEVICE_DATA_RDONLY

PUBLIC :: PAIR_GATHER_DEVICE_DATA_RDONLY


INTERFACE PAIR_GATHER_DEVICE_DATA_RDWR
  MODULE PROCEDURE :: PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDWR
END INTERFACE PAIR_GATHER_DEVICE_DATA_RDWR

PUBLIC :: PAIR_GATHER_DEVICE_DATA_RDWR


INTERFACE PAIR_GATHER_HOST_DATA_RDONLY
  MODULE PROCEDURE :: PAIR_FIELD_2RD_GATHER_HOST_DATA_RDONLY
END INTERFACE PAIR_GATHER_HOST_DATA_RDONLY

PUBLIC :: PAIR_GATHER_HOST_DATA_RDONLY


INTERFACE PAIR_GATHER_HOST_DATA_RDWR
  MODULE PROCEDURE :: PAIR_FIELD_2RD_GATHER_HOST_DATA_RDWR
END INTERFACE PAIR_GATHER_HOST_DATA_RDWR

PUBLIC :: PAIR_GATHER_HOST_DATA_RDWR


INTERFACE PAIR_SCATTER_DATA
  MODULE PROCEDURE :: PAIR_FIELD_2RD_SCATTER_DATA
END INTERFACE PAIR_SCATTER_DATA

PUBLIC :: PAIR_SCATTER_DATA

TYPE FIELD_2RD_SHUFFLE_PAIR
  INTEGER (KIND=JPIM) :: IMODE = -1
  INTEGER (KIND=JPIM) :: IWHAT = -1
  CLASS (FIELD_2RD), POINTER :: YLSCAT => NULL ()
  CLASS (FIELD_2RD), POINTER :: YLGATH => NULL ()
  TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: NEXT => NULL ()
END TYPE FIELD_2RD_SHUFFLE_PAIR

PUBLIC :: FIELD_2RD_SHUFFLE_PAIR


INTEGER (KIND=JPIM), PARAMETER :: NRDWR = 0, NRDONLY = 1, NHOST = 2, NDEVICE = 3
INTEGER (KIND=JPIM), PARAMETER :: NLONDIM = 1, NBLKDIM = 2

CONTAINS



SUBROUTINE PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDONLY (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
REAL(KIND=JPRD),                      POINTER              :: PTR(:,:)
CLASS (FIELD_2RD),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

REAL(KIND=JPRD), POINTER :: ZTRG(:,:), ZTRS(:,:)
REAL(KIND=JPRD), POINTER :: PTR1(:,:)
TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_2RD), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (2), IUBOUNDS (2)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_DEVICE_DATA_RDONLY (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):, 1:) => PTR1

ELSE

  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDONLY
  YLPAIR%IWHAT = NDEVICE
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (2) = 1
  IUBOUNDS (2) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
  ZTRS => GET_DEVICE_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_DEVICE_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_2RD_DEVICE_RDONLY (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDONLY (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_2RD_DEVICE_RDONLY (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG



DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRG (JLONG, JBLKG) = PTRS (JLONS, JBLKS)
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDONLY


SUBROUTINE PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDWR (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
REAL(KIND=JPRD),                      POINTER              :: PTR(:,:)
CLASS (FIELD_2RD),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

REAL(KIND=JPRD), POINTER :: ZTRG(:,:), ZTRS(:,:)
REAL(KIND=JPRD), POINTER :: PTR1(:,:)
TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_2RD), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (2), IUBOUNDS (2)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_DEVICE_DATA_RDWR (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDWR (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):, 1:) => PTR1

ELSE

  PTR => GET_DEVICE_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDWR
  YLPAIR%IWHAT = NDEVICE
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (2) = 1
  IUBOUNDS (2) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
  ZTRS => GET_DEVICE_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_DEVICE_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_2RD_DEVICE_RDWR (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_DEVICE_DATA_RDWR (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_2RD_DEVICE_RDWR (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG



DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRG (JLONG, JBLKG) = PTRS (JLONS, JBLKS)
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_2RD_GATHER_DEVICE_DATA_RDWR


SUBROUTINE PAIR_FIELD_2RD_GATHER_HOST_DATA_RDONLY (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
REAL(KIND=JPRD),                      POINTER              :: PTR(:,:)
CLASS (FIELD_2RD),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

REAL(KIND=JPRD), POINTER :: ZTRG(:,:), ZTRS(:,:)
REAL(KIND=JPRD), POINTER :: PTR1(:,:)
TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_2RD), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (2), IUBOUNDS (2)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_HOST_DATA_RDONLY (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDONLY (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):, 1:) => PTR1

ELSE

  PTR => GET_HOST_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDONLY
  YLPAIR%IWHAT = NHOST
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (2) = 1
  IUBOUNDS (2) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_HOST_DATA_RDONLY (YDFINDS)
  ZTRS => GET_HOST_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_HOST_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_2RD_HOST_RDONLY (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDONLY (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_2RD_HOST_RDONLY (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG


!$OMP PARALLEL DO PRIVATE (JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRG (JLONG, JBLKG) = PTRS (JLONS, JBLKS)
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_2RD_GATHER_HOST_DATA_RDONLY


SUBROUTINE PAIR_FIELD_2RD_GATHER_HOST_DATA_RDWR (YDPAIR, LDNULL, LDFULL, KLON, KGPBLKS, YDFINDS, PTR, YLF, KBLKMIN, KBLKMAX) 

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER              :: YDPAIR
LOGICAL,                                   INTENT (IN) :: LDNULL, LDFULL
INTEGER (KIND=JPIM),                       INTENT (IN) :: KLON, KGPBLKS
CLASS (FIELD_3IM),                POINTER              :: YDFINDS 
REAL(KIND=JPRD),                      POINTER              :: PTR(:,:)
CLASS (FIELD_2RD),              POINTER, OPTIONAL    :: YLF
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMIN
INTEGER (KIND=JPIM),                       INTENT (IN) :: KBLKMAX

REAL(KIND=JPRD), POINTER :: ZTRG(:,:), ZTRS(:,:)
REAL(KIND=JPRD), POINTER :: PTR1(:,:)
TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: YLPAIR
CLASS (FIELD_2RD), POINTER :: YLGATH_DUMM
INTEGER (KIND=JPIM) :: ILBOUNDS (2), IUBOUNDS (2)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

IF (LDNULL) THEN

  ! Return dummy pointer
  YLGATH_DUMM => NULL ()
  PTR => GET_HOST_DATA_RDWR (YLGATH_DUMM)

ELSEIF (LDFULL) THEN

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDWR (YLF)

  ! Set last lbound to 1

  ILBOUNDS = LBOUND (PTR)

  PTR1 => PTR (:, KBLKMIN:KBLKMAX)

  PTR (ILBOUNDS(1):, 1:) => PTR1

ELSE

  PTR => GET_HOST_DATA_RDONLY (YLF)

  ALLOCATE (YLPAIR)
  YLPAIR%IMODE = NRDWR
  YLPAIR%IWHAT = NHOST
  YLPAIR%NEXT => YDPAIR
  YDPAIR => YLPAIR
  YLPAIR%YLSCAT => YLF

  ILBOUNDS = LBOUND (PTR)
  IUBOUNDS = UBOUND (PTR)

  ILBOUNDS (1) = 1
  IUBOUNDS (1) = KLON

  ILBOUNDS (2) = 1
  IUBOUNDS (2) = KGPBLKS

  CALL FIELD_NEW (YLPAIR%YLGATH, LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS, PERSISTENT=.TRUE.)

  INDS => GET_HOST_DATA_RDONLY (YDFINDS)
  ZTRS => GET_HOST_DATA_RDONLY (YLPAIR%YLSCAT)
  ZTRG => GET_HOST_DATA_RDWR   (YLPAIR%YLGATH)

  CALL PAIR_FIELD_2RD_HOST_RDWR (INDS, ZTRG, ZTRS)

  ! Return pointer on packed array
  PTR => GET_HOST_DATA_RDWR (YLPAIR%YLGATH)

ENDIF


CONTAINS

SUBROUTINE PAIR_FIELD_2RD_HOST_RDWR (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN)  :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG


!$OMP PARALLEL DO PRIVATE (JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRG (JLONG, JBLKG) = PTRS (JLONS, JBLKS)
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_2RD_GATHER_HOST_DATA_RDWR



SUBROUTINE PAIR_FIELD_2RD_SCATTER_DATA (YDPAIR, YDFINDS)

USE FIELD_3IM_MODULE
USE FIELD_3IM_ACCESS_MODULE
USE FIELD_3IM_FACTORY_MODULE

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER              :: YDPAIR
CLASS (FIELD_3IM),               POINTER              :: YDFINDS 

TYPE (FIELD_2RD_SHUFFLE_PAIR), POINTER :: YLPAIR
REAL(KIND=JPRD), POINTER :: PTRG(:,:), PTRS(:,:)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)

DO WHILE (ASSOCIATED (YDPAIR))

  YLPAIR => YDPAIR%NEXT

  ! Scatter back results
  IF (YDPAIR%IMODE == NRDWR) THEN
    IF (YDPAIR%IWHAT == NDEVICE) THEN

      INDS => GET_DEVICE_DATA_RDONLY (YDFINDS)
      PTRG => GET_DEVICE_DATA_RDONLY (YDPAIR%YLGATH)
      PTRS => GET_DEVICE_DATA_RDWR   (YDPAIR%YLSCAT)

      CALL FIELD_2RD_SCATTER_DEVICE_KERNEL (INDS, PTRG, PTRS)

    ELSEIF (YDPAIR%IWHAT == NHOST) THEN

      INDS => GET_HOST_DATA_RDONLY (YDFINDS)
      PTRG => GET_HOST_DATA_RDONLY (YDPAIR%YLGATH)
      PTRS => GET_HOST_DATA_RDWR   (YDPAIR%YLSCAT)

      CALL FIELD_2RD_SCATTER_HOST_KERNEL (INDS, PTRG, PTRS)

    ENDIF
  ENDIF

  CALL FIELD_DELETE (YDPAIR%YLGATH)
  DEALLOCATE (YDPAIR)
  NULLIFY (YDPAIR)

  YDPAIR => YLPAIR
ENDDO

CONTAINS

SUBROUTINE FIELD_2RD_SCATTER_DEVICE_KERNEL (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN) :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG



DO JBLKG = 1, SIZE (KNDS, 3)

  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRS (JLONS, JBLKS) = PTRG (JLONG, JBLKG) 
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

SUBROUTINE FIELD_2RD_SCATTER_HOST_KERNEL (KNDS, PTRG, PTRS)

REAL(KIND=JPRD), POINTER :: PTRG(:,:)
REAL(KIND=JPRD), POINTER :: PTRS(:,:)
INTEGER (KIND=JPIM), INTENT (IN) :: KNDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG


!$OMP PARALLEL DO PRIVATE (JBLKG, JLONG, JBLKS, JLONS)
DO JBLKG = 1, SIZE (KNDS, 3)
  DO JLONG = 1, SIZE (KNDS, 2)
    JLONS = KNDS (NLONDIM, JLONG, JBLKG)
    JBLKS = KNDS (NBLKDIM, JLONG, JBLKG)
    IF (JLONS > 0) THEN
        PTRS (JLONS, JBLKS) = PTRG (JLONG, JBLKG) 
    ENDIF
  ENDDO
ENDDO

END SUBROUTINE

END SUBROUTINE PAIR_FIELD_2RD_SCATTER_DATA


END MODULE FIELD_2RD_SHUFFLE_MODULE
